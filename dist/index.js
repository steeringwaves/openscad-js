"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scad;
(function (Scad) {
    class Node {
        constructor(type, props) {
            this.type = type;
            this.props = props;
        }
    }
    Scad.Node = Node;
    class Variable {
        constructor(parent, name, value, opts) {
            this.parent = parent;
            this.name = name;
            this.value = value;
            this.opts = opts;
        }
        toString() {
            let comment = "";
            if (this.opts && this.opts.comment) {
                comment += `// ${this.opts.comment}\n`;
            }
            return `${comment}${this.parent.writeVariable(0, this.name, [this.value])}\n`;
        }
    }
    Scad.Variable = Variable;
    class Specials {
        constructor(parent) {
            this.parent = parent;
        }
        toString() {
            const entries = Object.entries(this).filter(([k, v]) => undefined !== v && "parent" !== k);
            if (0 === entries.length) {
                return "";
            }
            return `/* Specials */\n\n${entries.map(([k, v]) => this.parent.writeVariable(0, k, [v])).join("\n")}\n`;
        }
    }
    Scad.Specials = Specials;
    class Module {
        constructor(opts = {}) {
            this.entires = [];
            this.variables = [];
            this.indent = "\t";
            this.banner = `/* AUTOGENERATED FILE USING @steeringwaves/openscad-js DO NOT MODIFY */\n`;
            const proxyModules = new Proxy({
                _bg: this.defineModifier("%"),
                _debug: this.defineModifier("#"),
                _root: this.defineModifier("!"),
                _disable: this.defineModifier("*")
            }, {
                get: (obj, prop) => {
                    if (prop in obj) {
                        return obj[prop];
                    }
                    return this.defineModule(prop);
                }
            });
            this.any = proxyModules;
            this.modules = proxyModules;
            this.specials = new Specials(this);
            this.opts = opts;
            if (undefined !== opts.fs) {
                this.fs = opts.fs;
            }
            if (undefined !== opts.indent) {
                this.indent = opts.indent;
            }
            if (undefined !== opts.banner) {
                this.banner = opts.banner;
            }
        }
        addVariable(name, value, opts) {
            const v = new Variable(this, name, value, opts);
            this.variables.push(v);
            return v;
        }
        add(node) {
            this.entires.push(node);
            return node;
        }
        addMultiple(nodes) {
            this.entires.push(...nodes);
            return nodes;
        }
        toString() {
            let variableText = "";
            const sections = {};
            const noSections = [];
            for (let i = 0; i < this.variables.length; i++) {
                const v = this.variables[i];
                if (v.opts && v.opts.section) {
                    if (!sections[v.opts.section]) {
                        sections[v.opts.section] = [];
                    }
                    sections[v.opts.section].push(v);
                }
                else {
                    noSections.push(v);
                }
            }
            if (noSections.length > 0) {
                variableText += `/* Variables */\n\n`;
                variableText += noSections.map((v) => v.toString()).join("\n");
                variableText += `\n`;
            }
            // get list of sections alphabetically
            const sectionNames = Object.keys(sections).sort();
            // loop through all sections
            if (sectionNames.length > 0) {
                for (let i = 0; i < sectionNames.length; i++) {
                    const sectionName = sectionNames[i];
                    const section = sections[sectionName];
                    variableText += `/* [ ${sectionName} ] */\n\n`;
                    variableText += section.map((v) => v.toString()).join("\n");
                }
                variableText += `\n`;
            }
            return `${this.banner}\n${this.specials.toString()}\n${variableText}\n${this.compile(this.entires)}`;
        }
        toFile(filename, verbose) {
            if (!this.fs) {
                throw new Error("no filesystem module provided");
            }
            const scadSrc = this.toString();
            if (verbose) {
                console.log(scadSrc);
            }
            this.fs.writeFileSync(filename, scadSrc);
        }
        toScadFile(src, verbose) {
            this.toFile(sourceFilenameToScadFilename(src), verbose);
        }
        writeNode(depth, node) {
            if ("module" === node.type) {
                const props = node.props;
                return this.writeModule(depth, props.name, props.args, props.children);
            }
            if ("object" === node.type) {
                const props = node.props;
                return this.writeObject(depth, props.name, props.args);
            }
            if ("modifier" === node.type) {
                const props = node.props;
                return this.writeModifier(depth, props.symbol, props.child);
            }
            if ("variable" === node.type) {
                const props = node.props;
                return this.writeVariable(depth, props.name, props.args);
            }
            throw new Error(`unexpected node ${node}`);
        }
        writeIndent(depth) {
            return this.indent.repeat(depth);
        }
        writeModule(depth, name, args, children) {
            return `${name}(${this.writeArgs(args)}) {
		${children.map((c) => this.writeIndent(depth + 1) + this.writeNode(depth + 1, c)).join("\n")}
		${this.writeIndent(depth)}}`;
        }
        writeObject(depth, name, args) {
            return `${name}(${this.writeArgs(args)});`;
        }
        writeVariable(depth, name, args) {
            return `${name} = ${this.writeArgs(args)};`;
        }
        writeArgs(args) {
            return args
                .filter((arg) => "number" === typeof arg ||
                "boolean" === typeof arg ||
                "string" === typeof arg ||
                Array.isArray(arg) ||
                Object.entries(arg).length > 0)
                .map((arg) => this.writeValue(arg, true))
                .join(", ");
        }
        writeValue(value, isArg = false) {
            if (value instanceof Scad.Variable) {
                return value.name;
            }
            if ("number" === typeof value || "boolean" === typeof value) {
                return String(value);
            }
            if ("string" === typeof value) {
                return `"${value.replace(/"/g, '"')}"`;
            }
            if (Array.isArray(value)) {
                return `[${value.map((v) => this.writeValue(v)).join(", ")}]`;
            }
            if (isArg) {
                return Object.entries(value)
                    .map(([k, v]) => `${k}=${this.writeValue(v)}`)
                    .join(", ");
            }
            throw new Error(`unexpected value ${value}`);
        }
        writeModifier(depth, symbol, child) {
            return symbol + this.writeNode(depth, child);
        }
        compile(node) {
            if (Array.isArray(node)) {
                return node.map((n) => this.writeNode(0, n)).join("\n");
            }
            return this.writeNode(0, node);
        }
        defineModule(name) {
            return (...args) => {
                const result = function scadModule(...children) {
                    return { type: "module", props: { name, args, children } };
                };
                Object.assign(result, { type: "object", props: { name, args } });
                return result;
            };
        }
        defineModifier(symbol) {
            return (child) => ({ type: "modifier", props: { symbol, child } });
        }
    }
    Scad.Module = Module;
})(Scad || (Scad = {})); // namespace Scad
function sourceFilenameToScadFilename(src) {
    return `${src.replace(/\.ts$/i, "").replace(/\.js$/i, "")}.scad`;
}
exports.default = Scad;
//# sourceMappingURL=index.js.map